use gosub_interface::document::Document;
use std::collections::HashMap;

use crate::parser::tree_builder::TreeBuilder;
use gosub_interface::config::HasDocument;
use gosub_interface::node::{ElementDataType, Node};
use gosub_shared::byte_stream::Location;
use gosub_shared::node::NodeId;
use gosub_shared::types::Result;

/// Enum of tasks that can be performed to add or
/// update nodes in the tree.
///
/// These tasks are generated by a `TreeBuilder` which is implemented
/// by `DocumentTaskQueue` which holds a handle to the actual Document
/// to commit changes to.
pub enum DocumentTask {
    CreateElement {
        name: String,
        namespace: String,
        parent_id: NodeId,
        position: Option<usize>,
        location: Location,
    },
    CreateText {
        content: String,
        parent_id: NodeId,
        location: Location,
    },
    CreateComment {
        content: String,
        parent_id: NodeId,
        location: Location,
    },
    InsertAttribute {
        key: String,
        value: String,
        element_id: NodeId,
        location: Location,
    },
}

/// Queue of tasks that will mutate the document to add/update
/// nodes in the tree. These tasks are performed sequentially in the
/// order they are created.
///
/// Once tasks are queued up, a call to `flush()` will commit all changes
/// to the DOM. If there are errors during the application of these changes,
/// `flush()` will return a list of the errors encountered but execution is not halted.
///
/// `create_element()` will generate and return a new `NodeId` for the parser to keep
/// track of the current context node and optionally store this in a list of open elements.
/// When encountering a closing tag, the parser must pop this ID off of its list.
pub struct DocumentTaskQueue {
    /// Internal counter of the next ID to generate from the `NodeArena`
    /// without actually registering the node.
    /// WARNING: if nodes are registered in the arena while tasks are being queued
    /// this could lead to conflicts in `NodeIds`. `NodeArena` should NOT be used directly
    /// if using a `DocumentTaskQueue`.
    #[allow(dead_code)]
    next_node_id: NodeId,
    /// List of tasks to commit upon `flush()` which is cleared after execution finishes.
    // IMPLEMENTATION NOTE: using a vec here since I'm assuming we are
    // executing all tasks at once. If we need to support stopping task
    // execution midway, then maybe a real "queue" structure that pops
    // completed tasks is needed.
    pub(crate) tasks: Vec<DocumentTask>,
}

impl DocumentTaskQueue {
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.tasks.is_empty()
    }

    pub fn flush<C: HasDocument>(&mut self, doc: &mut C::Document) -> Vec<String> {
        let mut errors = Vec::new();

        for current_task in &self.tasks {
            match current_task {
                DocumentTask::CreateElement {
                    name,
                    namespace,
                    parent_id,
                    position,
                    location,
                } => {
                    let node = C::Document::new_element_node(name, Some(namespace), HashMap::new(), *location);
                    doc.register_node_at(node, *parent_id, *position);
                }
                DocumentTask::CreateText {
                    content,
                    parent_id,
                    location,
                } => {
                    let node = C::Document::new_text_node(content, *location);
                    doc.register_node_at(node, *parent_id, None);
                }
                DocumentTask::CreateComment {
                    content,
                    parent_id,
                    location,
                } => {
                    let node = C::Document::new_comment_node(content, *location);
                    doc.register_node_at(node, *parent_id, None);
                }
                DocumentTask::InsertAttribute {
                    key, value, element_id, ..
                } => {
                    // Invalid ID value?
                    if key == "id" && !is_valid_id_attribute_value(value) {
                        errors.push(format!("ID attribute value '{value}' did not pass validation"));
                        continue;
                    }

                    // An ID must be tied to only one element
                    let named_node = doc.node_by_named_id(value);
                    if named_node.is_some() && named_node.unwrap().id() != *element_id {
                        errors.push(format!("ID attribute value '{value}' already exists in DOM"));
                        continue;
                    }

                    let Some(node) = doc.node_by_id(*element_id) else {
                        errors.push(format!("Node id {element_id} not found"));
                        continue;
                    };

                    if !node.is_element_node() {
                        errors.push(format!("Node id {element_id} is not an element"));
                        continue;
                    }

                    let mut node = node.clone();

                    let element_data = node.get_element_data_mut().unwrap();
                    element_data.add_attribute(key, value);

                    doc.update_node(node);
                }
            }
        }
        self.tasks.clear();

        errors
    }
}

/// according to HTML spec: <https://html.spec.whatwg.org/#global-attributes>
pub(crate) fn is_valid_id_attribute_value(value: &str) -> bool {
    !(value.is_empty() || value.contains(|ref c| char::is_ascii_whitespace(c)))
}

// See tree_builder.rs for method comments
impl TreeBuilder for DocumentTaskQueue {
    fn create_element(
        &mut self,
        name: &str,
        parent_id: NodeId,
        position: Option<usize>,
        namespace: &str,
        location: Location,
    ) -> NodeId {
        let element = DocumentTask::CreateElement {
            name: name.to_owned(),
            parent_id,
            position,
            namespace: namespace.to_owned(),
            location,
        };
        let new_id = self.next_node_id;
        self.next_node_id = self.next_node_id.next();
        self.tasks.push(element);

        new_id
    }

    fn create_text(&mut self, content: &str, parent_id: NodeId, location: Location) -> NodeId {
        let text = DocumentTask::CreateText {
            content: content.to_owned(),
            parent_id,
            location,
        };
        let new_id = self.next_node_id;
        self.next_node_id = self.next_node_id.next();
        self.tasks.push(text);

        new_id
    }

    fn create_comment(&mut self, content: &str, parent_id: NodeId, location: Location) -> NodeId {
        let comment = DocumentTask::CreateComment {
            content: content.to_owned(),
            parent_id,
            location,
        };
        let new_id = self.next_node_id;
        self.next_node_id = self.next_node_id.next();
        self.tasks.push(comment);

        new_id
    }

    fn insert_attribute(&mut self, key: &str, value: &str, element_id: NodeId, location: Location) -> Result<()> {
        let attribute = DocumentTask::InsertAttribute {
            key: key.to_owned(),
            value: value.to_owned(),
            element_id,
            location,
        };
        self.tasks.push(attribute);
        Ok(())
    }
}

impl DocumentTaskQueue {
    pub fn new<C: HasDocument>(doc: &C::Document) -> Self {
        let next_node_id = doc.peek_next_id();
        Self {
            next_node_id,
            tasks: Vec::new(),
        }
    }
}
